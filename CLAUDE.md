# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

This is an Optical Music Recognition (OMR) application that converts scanned sheet music PDFs into structured MusicXML format using Audiveris, then parses and extracts musical metadata.

## Architecture

The codebase is organized as a single-file Python CLI (`cli.py`) with three main functional components:

### 1. PDF to MusicXML Conversion (`run_audiveris`)
- Integrates with Audiveris macOS application to perform OMR on PDF sheet music
- Uses Audiveris CLI in batch mode: `/Applications/Audiveris.app/Contents/MacOS/Audiveris`
- Creates temporary working directory for conversion output
- Searches for generated `.mxl`, `.musicxml`, or `.xml` files
- Copies result to same directory as input with appropriate extension

### 2. MXL Archive Extraction (`unzip_mxl`)
- MXL files are ZIP archives containing MusicXML + metadata
- Extracts to `{filename}_unzipped/` directory
- Contains MusicXML file and META-INF folder with container info

### 3. MusicXML Parsing (`parse_musicxml`)
- Parses MusicXML (version 4.0.3) using ElementTree
- Handles namespaced XML elements
- Extracts structural metadata into `MusicXMLFile` dataclass:
  - Key signature (fifths notation: -7 to +7)
  - Time signature (beats, beat-type tuple)
  - Part name
- Note: MusicXML structure is hierarchical: `score-partwise` → `part` → `measure` → musical elements

## Running the Application

### Execute the main CLI
```bash
python3 cli.py
```

Currently the script has hardcoded execution at the bottom (lines 140-143):
- Commented out OMR conversion and unzip operations
- Actively parsing example file: `sheet1_unzipped/sheet1.xml`

### Dependencies
- Python 3.11+ (uses dataclasses, pathlib, typing)
- Standard library only (no external packages required)
- Audiveris 5.7.1+ installed at `/Applications/Audiveris.app/Contents/MacOS/Audiveris`

## Development Commands

### Run individual functions interactively
```python
from cli import run_audiveris, unzip_mxl, parse_musicxml

# Convert PDF to MusicXML
run_audiveris("path/to/sheet.pdf")

# Extract MXL archive
unzip_mxl("path/to/file.mxl")

# Parse MusicXML
metadata = parse_musicxml("path/to/file.xml")
print(metadata)
```

### Test with sample data
The repository includes test files:
- `sheet1.pdf` - Original scanned sheet music
- `sheet1.mxl` - Generated MusicXML archive
- `sheet1_unzipped/` - Extracted MXL contents
- `sheet1_unzipped/sheet1.xml` - Actual MusicXML data

## Key Technical Details

### MusicXML Format
- Version: 4.0.3 (DTD: `http://www.musicxml.org/dtds/partwise.dtd`)
- Generated by: Audiveris 5.7.1 + ProxyMusic 4.0.3
- Structure: Uses `score-partwise` root element
- May include XML namespaces (handled via namespace extraction in parse function)

### Audiveris Integration
- Batch mode: `-batch` flag for non-interactive execution
- Export flag: `-export` generates MusicXML output
- Output directory: `-output` specifies where files are written
- Returns non-zero exit codes on failure

### File Paths
All file paths should use `Path(file).expanduser().resolve()` pattern for cross-platform compatibility and home directory expansion.

## Current Features

### Desktop GUI (`main.py`)
- Tkinter-based GUI application
- Upload PDF → converts via Audiveris → parses MusicXML
- Displays current key signature, time signature, and part name
- Transpose to any major key (-7 flats to +7 sharps)
- Convert transposed MusicXML to PDF using MuseScore
- Window size: 600x700px

### Transposition (`transpose.py`)
- Transposes MusicXML files between any major keys
- Handles chromatic pitch calculation and octave boundaries
- Automatically uses sharps/flats based on target key
- Updates all `<pitch>` elements and `<key>` signatures in the XML
- Outputs new transposed MusicXML file

### PDF Conversion (`convert_musicxml_to_pdf` in `cli.py`)
- Uses MuseScore 4 CLI to render MusicXML as PDF
- MuseScore path: `/Applications/MuseScore 4.app/Contents/MacOS/mscore`
- Command: `mscore -o output.pdf input.xml`

## Future Development Plan: Multi-Platform App

### Planned Architecture (Flutter + FastAPI)

The application will be rebuilt as a cross-platform mobile and desktop app:

**Target Platforms:**
- iOS (iPhone & iPad)
- Android (phones & tablets)
- macOS (desktop)
- Windows (desktop)

**Technology Stack:**
- **Frontend**: Flutter (Dart) - single codebase for all platforms
- **Backend**: FastAPI (Python) - hosted in cloud
- **Processing**: Audiveris & MuseScore running on cloud server

**Why Cloud Backend:**
- Audiveris and MuseScore cannot run on iOS/Android (desktop-only apps)
- Cloud processing enables mobile app functionality
- Centralized processing ensures consistent results across all platforms

### Architecture Design

```
Flutter App (iOS/Android/macOS/Windows)
    ↓ HTTP/REST API
FastAPI Backend (Railway/Render/DigitalOcean)
    ↓ Subprocess calls
Audiveris (PDF → MusicXML)
transpose.py (MusicXML transposition)
MuseScore (MusicXML → PDF)
```

### API Endpoints (✅ IMPLEMENTED)

The FastAPI backend is located in `/api/main.py` and implements:

```
POST /api/upload-pdf
    - Accepts PDF file upload
    - Runs Audiveris conversion
    - Returns session_id + metadata (key, time, part)

POST /api/transpose
    - Accepts session_id + target_key
    - Runs transposition logic
    - Returns success confirmation

POST /api/convert-to-pdf
    - Accepts session_id
    - Runs MuseScore conversion
    - Returns rendered PDF file

GET /api/keys
    - Returns list of all available keys for dropdown

GET /api/health
    - Returns {"status": "ok"} for health checks
```

**Session Management:**
- UUID-based sessions for multi-step workflow
- Temporary file storage in system temp directory
- Sessions expire after 1 hour (cleanup recommended for production)

### Development Phases

**Phase 1: FastAPI Backend** ✅ COMPLETE
- ✅ Converted existing Python functions to REST API endpoints
- ✅ Added file upload/download handling
- ✅ Implemented session/file storage
- ✅ Created Dockerfile for cloud deployment
- ✅ Deployed to Railway (https://github.com/HariKoor/OMR_API)

**Phase 2: Flutter App**
- Create Flutter project with multi-platform support
- Build UI matching current Tkinter design
- Implement file picker and network calls
- Add upload progress indicators

**Phase 3: Testing & Distribution**
- Test on iOS Simulator, iPad, Android emulator
- Test on macOS and Windows desktop
- Submit to Apple App Store ($99/year)
- Submit to Google Play Store ($25 one-time)

### Cost Estimates
- Cloud hosting: ~$5-20/month (Railway/Render)
- Apple Developer Account: $99/year
- Google Play Developer: $25 one-time
- **Total Year 1**: ~$200-250

### Notes for Future Development
- Must maintain Python backend for Audiveris/MuseScore integration
- Flutter requires Xcode (iOS) and Android Studio (Android emulator) installed
- Code in Dart/Flutter only - no separate Xcode/Android coding needed
- Single codebase generates apps for all 6 platforms

## Deployment

### Cloud Hosting Setup

The API is deployed to **Railway** (https://railway.app) with automatic deployments from GitHub.

**Repository:** https://github.com/HariKoor/OMR_API

**Deployment Pipeline:**
1. Code changes pushed to GitHub
2. Railway detects changes automatically
3. Builds Docker container from Dockerfile
4. Deploys to production (10-15 minutes first time, 3-5 minutes for updates)

### Docker Configuration

The Dockerfile (`/Dockerfile`) handles cross-platform compatibility:

**Base Image:** Ubuntu 22.04

**Installed Software:**
- Python 3 + pip
- Java Runtime (for Audiveris)
- Audiveris 5.7.1 (via official .deb package)
- MuseScore 3 (via apt-get)
- FastAPI dependencies (from api/requirements.txt)

**Key Installation Details:**
- Audiveris is installed using the official Ubuntu 22.04 .deb package
- Download URL: `https://github.com/Audiveris/audiveris/releases/download/5.7.1/Audiveris-5.7.1-ubuntu22.04-x86_64.deb`
- Binary location: `/usr/bin/audiveris`
- This method is more reliable than manual JAR extraction

**Environment Variables:**
```bash
AUDIVERIS_BIN=/usr/bin/audiveris
MUSESCORE_BIN=musescore3
PYTHONUNBUFFERED=1
```

### Platform Detection

The `cli.py` file auto-detects the operating system:

```python
import platform
SYSTEM = platform.system()

if SYSTEM == "Darwin":  # macOS (development)
    AUDIVERIS_BIN = "/Applications/Audiveris.app/Contents/MacOS/Audiveris"
    MUSESCORE_BIN = "/Applications/MuseScore 4.app/Contents/MacOS/mscore"
elif SYSTEM == "Linux":  # Linux (production/cloud)
    AUDIVERIS_BIN = "/usr/bin/audiveris"
    MUSESCORE_BIN = "musescore3"
```

This allows the same code to work on both macOS (local development) and Linux (cloud production).

### Deployment Lessons Learned

**Initial Issues:**
1. First attempt used non-existent .zip download URLs (5.3.1, 5.2) - both returned 404 errors
2. Solution: Use official .deb package from latest release (5.7.1)
3. The .deb package handles all dependencies and installs to standard system paths

**Testing Deployment:**
Before deploying, test Docker build locally:
```bash
docker build -t music-transposer-api .
docker run -p 8000:8000 music-transposer-api
curl http://localhost:8000/api/health
```

**Update Process:**
```bash
git add .
git commit -m "Update message"
git push
# Railway auto-deploys in 3-5 minutes
```

## Future Extension Points

The current implementation only extracts basic metadata (key, time, part name). To add more musical element extraction:

- **Notes/Pitches**: Parse `<note>` elements with `<pitch>` children (step, alter, octave)
- **Rhythms**: Extract `<duration>` and `<type>` (whole, half, quarter, etc.)
- **Dynamics**: Look for `<direction>` → `<dynamics>` elements
- **Lyrics**: Parse `<lyric>` → `<syllabic>` and `<text>` elements
- **Multiple Parts**: Iterate through all `<part>` elements (current code only gets first part-name)
- **Measures**: Process individual `<measure>` elements for bar-by-bar analysis
